#!/usr/bin/perl 

use Getopt::Long;
use Switch;
use strict;
use warnings;

use FindBin ();
use lib "$FindBin::Bin/lib";
use Utils;
use OGRUtils;

#general parameters
my %params = Utils::getParams();
my $project_dir=$params{'project_dir'};
my $debug=$params{'debug'};



# read input parameters:
#
# = indicates mandatory options
# : indicates optional options
#
GetOptions(
	"unique_code=s" => \my $unique_code,
	"input_file=s" => \my $input_file,
	"input_mimetype:s" => \my $input_mimetype,
	"method=s" => \my $method,
	"threshold:s" => \my $threshold,
	"percentage_vertices_output:s" => \my $percentage_vertices_output,
	"look_ahead:s" => \my $look_ahead,
	"output_file=s" => \my $output_file,
	"output_mimetype:s" => \my $output_mimetype,
	"output_types:s" => \my $output_types
);

my @output_types_array = ();
if ($output_types) {
	@output_types_array = split(/,/,$output_types);
}


##########################
# Check input parameters #
##########################

#1. check mandatory parameters
if (!(defined ($unique_code) && defined ($input_file) && defined ($method) && defined ($output_file))) {
	print "One or more parameters are missing or invalid (string were integer is expected)\n";
	exit 1;
}


# 2. check if the method is one of the following: douglas, douglas_reduction, lang, reduction, reumann, remove_small
my @valid_methods = ("douglas", "douglas_reduction", "lang", "reduction", "reumann", "remove_small");
if (! (grep $_ eq $method, @valid_methods) ) {
	print "Only the following mehods are allowed: douglas, douglas_reduction, lang, reduction, reumann and remove_small\n";
	exit 1;
}


# 3. check if all output types are one of the following: point, kernel, centroid, line, boundary, area, face
for my $output_type (@output_types_array) {
	my @valid_output_type = ("point", "kernel", "centroid", "line", "boundary", "area", "face");
	if (! (grep $_ eq $output_type, @valid_output_type) ) {
		print "Only the following output types are allowed: point, kernel, centroid, line, boundary, area and face\n";
		exit 1;
	}
} 


#################
# Set variables #
#################

my $location="Location_$unique_code";

#derived parameters
my $work_dir= "$project_dir/work/$unique_code";

# create working directory
mkdir($work_dir, 0755) or die "cannot mkdir $work_dir: $!";


if (! defined ($threshold)) {
	$threshold = "";
} elsif ($threshold ne "") {
	$threshold = "threshold=${threshold}";
}

if (! defined ($percentage_vertices_output)) {
	$percentage_vertices_output = "";
} elsif ($percentage_vertices_output ne "") {
	$percentage_vertices_output = "reduction=${percentage_vertices_output}";
}

if (! defined ($look_ahead)) {
	$look_ahead = "";
} elsif ($look_ahead ne "") {
	$look_ahead = "look_ahead=${look_ahead}";
}


my $output_format="";
if (defined($output_mimetype) && $output_mimetype ne "") {
	print "Set output format\n";
	print "Output MimeType: $output_mimetype\n";
	$output_format = OGRUtils::getOGRFormatByMimeTypeInGrassStyle($output_mimetype);
	if ($output_format ne "") {
		$output_format = "format=\"$output_format\"";
	}
	print "Output format: $output_format\n";
}

#If MapInfo File is the output format, specify that we want to create MIF/MID files
#Otherwise, TAB files are created
my $dataset_creation_option = "";

if ($output_format eq "format=\"MapInfo File\"") {
	$dataset_creation_option = "dsco FORMAT=MIF";
}

if (! defined ($output_types)) {
	$output_types = "";
} elsif ($output_types ne "") {
	$output_types = "type=$output_types";
}




##############
# Processing #
##############

Utils::printStart($unique_code, $debug);

if($input_mimetype eq "application/x-esri-shapefile") {
	my $output_dir= "$work_dir/vector";
	$input_file = Utils::unzip($input_file, $output_dir, $debug);
}

# import vector into new location
Utils::execute("v.in.ogr dsn=\"$input_file\" output=vector location=$location", $debug);

# change location
Utils::execute("g.mapset mapset=PERMANENT location=$location", $debug);


# get generalize options depending on method
my $generalize_options = "";
switch ( $method ) {
	case "douglas" {
		$generalize_options = "$threshold";
	}
	case "douglas_reduction" {
		$generalize_options = "$threshold $percentage_vertices_output";
	}
	case "lang" {
		$generalize_options = "$threshold $look_ahead";
	}
	case "reduction" {
		$generalize_options = "$threshold";
	}
	case "reumann" {
		$generalize_options = "$threshold";
	}
	case "remove_small" {
		$generalize_options = "$threshold";
	}
}


# generalize vector
Utils::execute("v.generalize input=vector output=output_vector method=$method $generalize_options", $debug);

#use v.build to correct errors generated by v.generalize
Utils::execute("v.build map=output_vector", $debug);


#if output is shapefile, ZIP it
if ( (!defined($output_mimetype)) && $output_mimetype eq "" || $output_mimetype eq "application/x-esri-shapefile") {
	
	# create output directory
	my $output_dir = "$work_dir/output";
	mkdir($output_dir, 0755) or die "cannot mkdir $output_dir: $!";
	
	# create output
	Utils::execute("v.out.ogr input=output_vector dsn=$output_dir $output_format $dataset_creation_option $output_types", $debug);
	
	# zip the shapefiles
	Utils::zip("zip $output_file *", $output_dir, $output_file, $debug);
	
} else {
	# create output
	Utils::execute("v.out.ogr input=output_vector dsn=$output_file $output_format $dataset_creation_option $output_types", $debug);
}

Utils::printEnd($unique_code, $debug);

