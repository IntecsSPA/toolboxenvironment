<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet href="doc.xsl" type="text/xsl"?><site-map><pages-div><html-page menu-item="Home" file="index"><head><title>DOPS-Data Organizing and Processing Software</title><meta content="Data Organizing and Processing - Web site developer tools - Data management systems" name="Description"/><meta content="web site developer tools processing organizing data management systems" name="Keywords"/></head><img-text-block><b>Data Organizing</b><br/><br/>The ability to exchange and share information by Internet is, nowadays, a necessary condition for successful activity of many industrial, commercial and educational organizations. Number of Internet Technologies and tools increases rapidly to suit their needs. No one knows at the beginning of the information revolution, which of the Technology will dominate in the future. Relying on modern trends in information technologies, we develop tools for data organizing and management. Data organizing systems are less restrictive than data management systems. Data management systems deal typically with the structured data.  <br/><br/></img-text-block><img-text-block><b>Data Processing</b><br/><br/>Unlike human, processing, transforming and understanding data are almost the same things for a computer. The complexity of the transformation an application can do is the measure of its intelligence. Could the World Wide Web become the World Wide Intelligent Web? We don't know. XML Technology is one of the candidate technologies capable to achieve this goal. An interesting feature of XML is a potential possibility for &quot;trunsmulation&quot; of data objects and programs. We can convert the data object to a program and we can transform the program to a data object. Certainly, the use of this kind of duality in a real application is more than untrivial task.<br/><br/></img-text-block><img-text-block><b>Concepts</b><br/><br/>Most of the products you will find on this website are the final user programs and web developer tools simultaneously. A developer role is to  program the tool properly. The programming language used is that of restrictive purposes hence it is more simple than universal purpose languages. We think that XSLT language satisfies our requirements.<br/><br/></img-text-block><img-text-block><b>The first step</b><br/><br/>Perl XSLT engine is our first product appeared in Match of 2004. We were not going to take part in competition with other XSLT engines. The goal of the project was to understand whether XML Technology could be useful for unstructured data organizing. Web applications were of our special interest. WebSite Content Extensible Editor (WCX Editor) is an XSLT application with no intent of transforming anything. We use WCX Editor to store and support the structure of the web site and as a publishing tool.</img-text-block></html-page><menu.items title="Products"><html-page menu-item="CGI XSLT Engine" file="xslt_parser"><head><title>CGI XSLT engine - Perl XSLT parser</title><meta content="CGI XSLT engine is a pure Perl XSLT parser that uses HTTP as parameters passing protocol" name="Description"/><meta content="XSLT parser XSLT processor XSLT engine Perl CGI" name="Keywords"/></head><img-text-block><b>CGI XSLT engine - Perl XSLT parser</b><br/><br/>Our XSLT engine is a server-side solution for XML/XSLT combination. It is written in Perl. The XSLT parser has almost no prerequisite Perl packages. It can read parameters and files passed by a browser through HTML form. It has simple mechanism for xml files update and creation. The XSLT processor is ready for use CGI program. The parser implements all main XSLT 1.0 instructions. It supports both unicode and bytes characters models. And, It has sufficient performance for many problems. <br/><br/>CGI XSLT processor doesn't support all XSLT 1.0 instruction and functions. Also it has a few extension functions. The parser treats result tree fragments as in XSLT 2.0. Namely, they are always converted to node-sets. The XSLT processor uses different method for conflict resolution of template rules which can be explained as follows. The more informative the template pattern is the higher priority it has.  Local variable declared can be accessed in any template called after its declaration. This simplifies the development of XSLT programs in many cases. We do not support URLs either. All files, XSLT stylesheets and XML sources, must be on the local host. However, external entities can be used for remote XML sources processing.<br/><br/>Since version 1.5 CGI XSLT processor can load  Perl modules that implement extension instructions and functions.<br/><br/></img-text-block><img-text-block><b>Overview of XML and XSLT</b><br/><br/>The most remarkable thing concerning XML is that you need to understand just one sentence to use it. Here it is &quot;Extensible Markup Language, abbreviated XML, describes a class of data objects called XML documents and partially describes the behavior of computer programs which process them&quot; (W3C RFC-xml). Let read it word by word.<br/><br/><i>Markup.</i> Elements of markup are the named brackets called tags. There are the open tag &lt;elementname&gt; and the close tag &lt;/ementname&gt;. The string between them is an element content. It consists of text and other markup elements (tags). The text strings are the data of XML document. The tag elements with their content are the data objects. The data object can have attributes as well (&lt;el a1=&quot;1&quot;&gt;...&lt;/el&gt;). You are surely familiar with all this since HTML documents have the same structure. One thing is worth mentioning empty elements are represented now as &lt;elementname/&gt; (not just &lt;elementname&gt;). <br/><br/><i>Extensible.</i> The word extensible means ultimately that XML has no predefined element names (tag names). If this is the case what can you do with XML? Nothing! You should first determine what data objects you need and name them. Sometimes, it can be difficult, however, once created the markup can be reused. <br/><br/><i>Language.</i> Despite XML RFC has a small set of definitions that allow you to declare types of data objects XML is not a programming language. It is better to say it states the grammar of language family. Each language in this family has its own semantics and intent of usage.<br/><br/>The computer program, which processes xml files, is XML parser (processor). Almost 80% of the content of W3C XML Recommendation are dedicated to the developers of XML parsers.<br/><br/>XSLT is a language for transforming one XML document to other XML (or HTML) document (W3C RFC-xslt). It belongs to XML language family. XSLT programs are conventionally called stylesheets. However, they are not stylesheets in the usual sense and have no relation to CSS. Modern browsers support XSLT language but XSLT program does not provide a browser with the information about how it must render the XML document. Instead it instructs the browser: transform the document to a new one and then render this new document. We can do this transformation on the server side compiling the data files to the formats ready for rendering. To be a publishing tool XSLT must have an instruction that tells  XSLT processor where the result document must be saved. It is not a problem and our Perl XSLT engine has it.<br/><br/>Update, delete and insert operations are also operations of data transformation kind hence XSLT language is capable to describe them. A missing point here is that XSLT language has no protocol for parameters passing. CGI XSLT processor has it. The XSLT parser uses HTTP protocol to read parameters passed by HTML forms. This gives much more power to XSLT stylesheet. The XSLT stylesheet can now generate and process HTML forms.<br/><br/></img-text-block><img-text-block><b>DOM and XSLT</b><br/><br/>The &quot;save to file&quot; instruction we have added to the XSLT engine makes XML/XSLT and XML/DOM completely interchangeable (just &quot;save the result to file&quot; is not enough for this claim).  Any DOM application can be redesigned in XSLT application and vice versa.<br/><br/>DOM object on a server is created through parsing XML file each time the program called. The same statement is true for XSLT. In theory DOM must be faster for simple transformations (attribute value update or something similar). We assume that XSLT engine does not use DOM object insight. If it is DOM is always faster. XSLT is easier in use and is much more productive tool.<br/><br/><ref file="doc/description">More details</ref></img-text-block></html-page><html-page menu-item="Website Content Editor" file="website_content_editor"><head><title>WCX Editor-Simple Website Content Management system</title><meta name="Description" content="Website Content Editor - Simple Website Content Management system that creates web pages,inserts image,buids lists"/><meta name="Keywords" content="edit website,content management system,website content editor,site manager"/></head><img-text-block><b>WebSite Content Extensible Editor (WCX Editor)</b><br/><br/>is a simple web content management system built with XSLT stylesheets. It is a tool for the person who creates and edits the website content (what a web site that is about something is about). It is not a web developer tool for website content (collection for everything) editing.<br/><br/>WCX Editor provides a solution that allows non-technical people to manage entire web site organizing web pages into menu items, inserting images, building lists, and adding links and text. It is forms-based, writers cut and paste the content and press the publish link when the web page is ready. The updated page appears instantly and looks the same way as the web site visitors will see it.<br/><br/>Like all website content management systems (CMS) it can not be installed without a web developer with &quot;right knowledge&quot;. The package is freely distributed as a collection of abstract classes, universal purpose utilities, template samples and documentation. Unlike many website CMS, it is essentially one user system. Two users can not edit web site simultaneously. WCX Editor does not use a relational database. WCX Editor is based on XML Technology and inherits extensibility from XML language. It requires that CGI XSLT processor be installed. <br/></img-text-block><html-code file="demo"/><img-text-block><ref file="wcx_editor/edit_website">Web Editor</ref><br/><br/><ref file="wcx_editor/user_guide">User's Guide</ref><ul><li><ref file="wcx_editor/page_menu">The page menu</ref></li><li><ref file="wcx_editor/content_menu">The content menu</ref></li><li><ref file="wcx_editor/images">Images</ref></li></ul><ref file="wcx_editor/designer_guide">Designer's Cuide</ref><ul><li><ref file="wcx_editor/menu_items_design">Menu items design</ref></li><li><ref file="wcx_editor/page_content_design">Page content design</ref></li><li><ref file="wcx_editor/html_code">HTML code insertion</ref></li></ul><ref file="wcx_editor/developer_guide">Developer's Guide</ref><ul><li><ref file="wcx_editor/parameters">Parameters</ref></li><li><ref file="wcx_editor/abstract_stylesheets">Abstract classes</ref></li><li><ref file="wcx_editor/utilities">WCX Editor utilities</ref></li></ul></img-text-block><html-code file="listings"/></html-page><html-page menu-item="Downloads" file="download"><head><title>Downloads</title><meta content="DOPS downloads" name="Description"/></head><img-text-block><b>CGI XSLT processor</b><br/><br/>VERSION 1.0 Put all files in your cgi-bin directory.<ul><li><a href="/downloads/xsltp10.zip">Download xsltp10.zip</a></li><li><a href="/downloads/xsltp10.tar.gz">Download xsltp10.tar.gz</a></li></ul>VERSION 1.5 Read readme file<ul><li><a href="/downloads/xsltp15.zip">Download xsltp15.zip</a></li><li><a href="/downloads/xsltp15.tgz">Download xsltp15.tgz</a></li></ul></img-text-block><img-text-block><b>WCX Editor</b><ul><li><a href="/downloads/wcxe10.zip">Download wcxe10.zip</a></li><li><a href="/downloads/dops.zip">Copy of dopscripts.com data file dops.zip</a></li><li><a href="/downloads/wcxe10.tar.gz">Download wcxe10.tar.gz</a></li><li><a href="/downloads/dops.tar.gz">Copy of dopscripts.com data file dops.tar.gz</a></li><li><ref file="wcx_editor/intallation">Installation</ref></li></ul><a href="/downloads/wcxexample.zip">Example.zip</a> explains how to use tables for menus design in XSLT.</img-text-block></html-page></menu.items><menu.items title="Information"><html-page menu-item="Support &amp; Contact" file="support"><head><title>Support and contact form of DOPS web site</title></head><img-text-block><b>Support &amp; Contact</b><br/><br/>Please, sending us a bug note, do not forget to mention your OS, Perl version and HTTP server. It is a good idea to attach xsltp.log file.  The size of the form data must be less than 100kb. Comments and Questions are also appreciated.</img-text-block><html-code file="support"/></html-page><html-page menu-item="Last updates" file="dops_updates"><head><title>Last updates</title><meta content="DOPS last updates" name="Description"/></head><img-text-block><b>WCX Editor</b><br/><br/></img-text-block><img-text-block>30 January 2005<ul><li>The bug in the utf-8 version of the editor corrected</li></ul></img-text-block><img-text-block><b>CGI XSLT processor release notes</b><br/><br/></img-text-block><img-text-block>12 June 2005<ul><li>Version 1.5 of xsltp.pl is now available</li><li>Documentation was updated</li></ul></img-text-block></html-page></menu.items></pages-div><pages-div><html-page file="doc/description" menu-item="XSLT Processor"><head><title>Xsltp.pl - Perl XSLT processor</title><meta name="Description" content="XSLT processor to work with XML/XSLT in Perl"/><meta name="Keywords" content="XSLT processor Perl xsltp.pl"/><meta name="Author" content="G. Varzugin"/></head><img-text-block><b>Perl CGI XSLT Processor</b><br/><br/>Xsltp.pl is a pure Perl XSLT processor. It requires XML::Parser and CGI packages and version of Perl 5.6.1 or higher. It supports XSLT 1.0 and XPath 1.0 W3C Recommendation. The built-in HTTP protocol makes the processor to be especially suited for Web development. Designed on &quot;top&quot; of Perl rather than &quot;inside&quot; of Perl it is ready for use CGI program. Open architecture of the processor allows developers to extend functionality of the XSLT processor by just coping the extension module, written in Perl, in the desired place and instructing the program that it must load it when the module is required by the XSLT stylesheet.<br/><br/>We provide three different methods for integration of the XSLT processor with Perl modules. The simplest one is xsl:message handlers. The XSL message handler is an independent package that defines the function message_handler. The input for the function is generated by the XSLT processor through processing the xsl:message element body and passing the result to the message_handler. The handler can open a file stream and print the result to it as XML/HTML document or convert the result to string and send the query to SQL server.<br/><br/>Extension instructions and functions are two other approaches. They are implemented by extension modules. The modules are loaded in the namespace of XSLT Perl package and XPath::Expression package. Possible names conflict should be resolved with the element name prefixes. The processor loads the extension when it finds the attribute xmlns:prefix=&quot;#module-name&quot; of the xsl:stylesheet element.<br/><br/>To reduce number of problems with encodings we also support bytes characters model. The reason for that is that it is difficult to detect the encoding of the external source of data. The bytes model is more limited than Unicode model. In particular, the use of character references and external entities is not permitted. Advantages of the bytes model is that the processor returns the data in the same format as it receives them from external source like SQL server or file. Recall Perl uses UTF-8 encoding as a default and converts to it every string when it is &quot;needed&quot;. Latin writers should not think about it at all.<br/><br/>The processor is also suitable for external parameter dependent display of XML files on a server-side. In addition, it has built-in extensions file upload feature, time functions, dynamic importing of sylesheets and method for HTTP headers printing.<br/><br/>The XSLT processor reads the parameters passed through HTTP GET or POST methods. The result documents can be saved to the local disk or(and) printed to STDOUT. A special element &quot;xml-document&quot; was introduced for the XSLT stylesheet can control the processor output. It is possible to add the code implementing a different method of parameters passing. The stylesheet must have the section of the global parameters declaration in this case either. Any parameter passed to the XSLT processor must have a type supported by it.<br/><br/></img-text-block><img-text-block><b>Performance</b><br/><br/>It seems that we get maximum possible performance for pure Perl solution. The execution time of the script depends linearly on the size of input and the size of output and varies with complexity of stylesheets. Gain from optimization of the compilation time can not be essential. It is due to the fact that 50% of the compilation time is spent by XML::Parser. Since version 1.5 the XSLT processor is compatible with mod_perl.<br/><br/></img-text-block><img-text-block><ref file="dops_updates">Last updates</ref> | <ref file="download">Downloads</ref> | <ref file="doc/st_and_src">How can I pass XSLT stylesheet and XML document?</ref><br/><br/><ref file="xslt_parser">Back to Introduction</ref></img-text-block></html-page><menu.items title="CGI XSLT Processor"><html-page menu-item="The style and source" file="doc/st_and_src"><head><title>The style and source parameters of CGI XSLT processor</title><meta content="The style and source parameters of CGI XSLT processor" name="Description"/><meta content="stylesheet source parameters xsltp.pl  XSLT parser processor " name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>The style and source parameters of XSLT engine</b><br/><br/>The main parameters of xsltp.pl Perl XSLT processor are style and source. You can pass them using GET or POST methods. The style parameter value is the name of the XSLT stylesheet to be executed and the source parameter value is the name of the XML document to be transformed. Typically, you will need to pass one of them. The only permitted extension of the style file is .xsl and the only permitted extension of the source file is .xml. These extensions will be added automatically if they are not provided. The program cannot process files with other extensions unless you load them explicitly by the stylesheet code. It is recommended to use not xml(xsl) extension for configuration files.<br/><br/><b>Security remark. </b>The XSLT processor can read valid XML documents only. There is must be a stylesheet to display the document. Hence if you'll design the stylesheets carefully the above recommendation can be ignored. The source and style parameters are protected against null terminated strings and Perl IO control characters attacks.<br/><br/>If the style parameter is not set then the program reads the processing instruction</img-text-block><pre>&lt;?xml-stylesheet href=&quot;filename.style&quot; type=&quot;text/xsl&quot;?&gt;
</pre><img-text-block>in the source file. If it is not present then xsltp.pl XSLT parser attempts to load the stylesheet with the same name as the source file and with .xsl extension. It is not an error if the source file is not passed. In this case your XSLT stylesheet must be prepared to start with the root node that has no children. Example,
</img-text-block><pre>/cgi-bin/xsltp.pl?style=doc/xsltp&amp;source=doc/xsltp
</pre><img-text-block><br/>The declaration of the style or source parameters in the stylesheet is not required, but if you need their values in the stylesheet code you can do this as</img-text-block><pre>&lt;xsl:param name=&quot;style&quot; as=&quot;string&quot;/&gt;
&lt;xsl:param name=&quot;source&quot; as=&quot;string&quot;/&gt;</pre><img-text-block><br/>The style and source parameters must be file names on the local host, usually, relative paths. It does not mean that you cann't process XML data source from remote host. Here is the code you will use to do this.</img-text-block><pre>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE my-news [&lt;!ENTITY news SYSTEM &quot;http://www.notdopscripts.com/xml/news.xml&quot;&gt;]&gt;
&lt;xsl:stylesheet version=&quot;1.0&quot;&gt;
&lt;xsl:variable name=&quot;news&quot;&gt;&amp;news;&lt;/xsl:variable&gt;
&lt;xsl:template match=&quot;/&quot;&gt;
&lt;xsl:for-each select=&quot;$news&quot;&gt;
....
&lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre><img-text-block>This method works if news.xml has no XML declaration or has XML declaration with encoding type. External entities are not allowed in bytes characters model. Notice that the requirement  for encoding in external entities is a corollary of XML physical structure definition. The XML parsers that don't follow the W3C Recommendation can read entities without encoding type.      <br/><br/><ref file="doc/xslt_passing_parameters">How do I pass parameters to XSLT stylesheet?</ref><br/><ref file="doc/chrsmodel">How do I use one byte encodings?</ref></img-text-block></html-page><html-page menu-item="Global parameters" file="doc/xslt_passing_parameters"><head><title>CGI XSLT Processor - Passing parameters to XSLT stylesheet</title><meta content="The method for passing parameters to XSLT stylesheet used by the xsltp.pl Perl XSLT processor" name="Description"/><meta content="passing parameters XSLT stylesheet global parameters types" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>Passing parameters to XSLT stylesheet</b><br/><br/>Xsltp.pl XSLT engine uses HTTP protocol built in the processor for passing the parameters to XSLT stylesheets. The parameter passed to the XSLT processor must be declared in the global parameters section of the XSLT stylesheet.<br/><br/>The Perl XSLT processor treats the global parameters as constants. The values of global parameters are XPATH expressions. These expressions are not evaluated. Instead, the reference to the global parameter will be replaced by the expression at compile time. If the global parameter is a result tree fragment its value is converted to the literal string expression. In addition, for the top xsl:param elements, &quot;as&quot; and &quot;max-size&quot; attributes are optional.<br/><br/>The parameters you wish to pass to the XSLT stylesheet must have &quot;as&quot; attribute. Xsltp.pl XSLT parser supports the following values of &quot;as&quot; attribute:</img-text-block><pre>int (or integer), unsigned-int (or unsignedInt), positiveInt (or positiveInteger),
number, string, expression, file,  set</pre><img-text-block>The last two types are converted to the global variables. Parameters of type expression passed to the XSLT stylesheet must not contain a reference to variable or parameter, the document function and any extension function. Parameters of type set are result tree fragments of the form</img-text-block><pre>&lt;xsl:param name=&quot;options&quot; as=&quot;set&quot; max-sixe=&quot;100&quot;&gt;
&lt;value&gt;1&lt;/value&gt;&lt;value&gt;2&lt;/value&gt;...&lt;/xsl:param&gt;
</pre><img-text-block>The following code determines is there 1 in the set</img-text-block><pre>&lt;xsl:if test=&quot;$options/value=1&quot;&gt;...&lt;/xsl:if&gt;</pre><img-text-block><br/>Here is an example of the HTML form which send the parameter of type set. It is assumed that stylesheet xml/checkbox.xsl defines the parameter named &quot;options&quot; either with default values as above or simply as</img-text-block><pre>&lt;xsl:param name=&quot;options&quot; as=&quot;set&quot;/&gt;
&lt;!-- HTML Form --&gt;
&lt;FORM action=&quot;/cgi-bin/xsltp.pl&quot; method=&quot;POST&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;style&quot; VALUE=&quot;xml/checkbox&quot;&gt;
value: &lt;INPUT TYPE=&quot;checkbox&quot; NAME=&quot;options&quot; VALUE=&quot;1&quot;&gt;
value: &lt;INPUT TYPE=&quot;checkbox&quot; NAME=&quot;options&quot; VALUE=&quot;2&quot;&gt;
value: &lt;INPUT TYPE=&quot;checkbox&quot; NAME=&quot;options&quot; VALUE=&quot;3&quot;&gt;
&lt;INPUT TYPE=&quot;submit&quot; NAME=&quot;test&quot; VALUE=&quot;send&quot;&gt;
&lt;/FORM&gt;
</pre><img-text-block><br/>The xsl:param element of string type can have the escape-chars attribute (v&gt;=1.5). It has no effect on the default value.</img-text-block><pre>&lt;xsl:param name=&quot;str&quot; as=&quot;string&quot; max-size=&quot;20&quot; escape-chars=&quot;'\n\r\\&quot; select=&quot;''&quot;/&gt;</pre><img-text-block><br/>The max-size attribute for set type means max size of the string value of the result tree fragment plus max number of values (this is technically convenient). For file type the max-size attribute is meaningless. For all rest types the max-size attribute sets the maximum allowed size of the string passed as a parameter value to the XSLT processor. You can set the default value of the parameter with the select attribute. It is an error if the parameter with no default value is not passed to the XSLT stylesheet. Not declared parameters are discarded. Xsltp.pl program also reads HTTP COOKIE. If a parameter with name x has been passed with GET or POST methods x parameter in the http cookie list is ignored. Passing expressions to the processor as external parameters, check your XSLT stylesheet for possible infinite loop. The Perl XSLT parser has no algorithm of the infinite loop detection. In fact, any CGI program has this algorithm even if its author doesn't want it.<br/><br/><ref file="doc/st_elements">How can I save the result document on the local disk?</ref><br/><ref file="doc/upload">What can I do with parameters of file type?</ref><br/><ref file="doc/document_function">How do I use the document function?</ref></img-text-block></html-page><html-page menu-item="Stylesheets" file="doc/stylesheets"><head><title>XSLT stylesheet top elements</title><meta content="XSLT stylesheet top elements supported by xsltp.pl parser" name="Description"/><meta content="XSLT stylesheet top elements" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>XSLT stylesheet top elements</b><br/><br/>Any stylesheet which can be processed by xsltp.pl CGI XSLT processor must contain the xsl:stylesheet (xsl:transform) element. This means that literal result elements are never treated as a stylesheet. The last restriction is necessary if you don't wish that xsltp.pl XSLT parser can display any xml files on your host. Notice also that if you don't overwrite the default template</img-text-block><pre>&lt;xsl:template match=&quot;/&quot;&gt;&lt;xsl:apply-templates/&gt;&lt;/xsl:template&gt;</pre><img-text-block>your stylesheet can display text data of any xml file! Always define the template above in the stylesheets direct call of which is not desired, e. g.</img-text-block><pre>&lt;xsl:template match=&quot;/&quot;&gt;&lt;html&gt;&lt;body&gt;text&lt;/body&gt;&lt;/html&gt;&lt;/xsl:template&gt;</pre><img-text-block>Supported top level elements:
</img-text-block><pre>xsl:template
xsl:key
xsl:include
xsl:import &lt;!-- Synonym for xsl:include, xsl:apply-imports instruction is not supported. --&gt;
xsl:variable
xsl:param
xsl:output &lt;!-- In addition, xsltp.pl XSLT parser supports omit-http-headers attribute 
Since version 1.5 we do not support indent attribute --&gt;
xsl:namespace-alias 
&lt;!--Namespace prefix defined by the stylesheet-prefix attribute will be 
replaced by the result-prefix attribute value provided that output method is xml.
Xsltp.pl processor does not support namespaces. This instruction is useful only if 
result-prefix=&quot;xsl&quot; or to the prefix of some loaded extension module.--&gt; 
</pre><img-text-block><br/>Not supported top level elements:</img-text-block><pre>xsl:strip-space, xsl:preserve-space, xsl:decimal-format, xsl:attribute-set
</pre><img-text-block>The strip-space and preserve-space XSLT elements are used to define the string values of nodes more precisely. The program employs a fixed data model. It merges all nearest text nodes then removes text nodes that contain just space characters except text nodes of PCDATA elements. The attribute-set element is a redundant instruction.<br/><br/>Extra top level elements of xsltp.pl Perl XSLT parser:</img-text-block><pre>&lt;xsltp:max-content-length select=&quot;integer&quot;/&gt;</pre><img-text-block>The sum of the select attribute values of all xsltp:max-content-length elements plus 1024 is the maximum value of HTTP content-length permitted.
</img-text-block><pre>&lt;xsl:message&gt;
</pre><img-text-block>It defines a message, which will be displayed if an error occurs. The error will be stored in xsltp.log file. If the top message element is not set the error will be printed to STDOUT. Notice that even if the stylesheet itself has no errors, the parameters passed may have invalid values. Moreover, you can pass XPATH expressions as stylesheet parameters. The element xsl:message or xsl:include instruction that imports stylesheet with the top xsl:message element must be the last elements of the stylesheet so that the program can read them first. You can get the error string as &lt;xsl:value-of select=&quot;error&quot;/&gt; (v&gt;=1.5). The element will not be compiled until the error heppens. XSL message handler can be used inside to send the error to the administrator e-mail. Since 1.5 all errors are saved in xsltp.log file.
</img-text-block><pre>&lt;xsltp:xml-base select=&quot;string&quot;/&gt;
&lt;!-- since 1.5 expression can be used. It is evaluated
with respect to root node of the source document --&gt;
&lt;xsltp:xml-base select=&quot;{XPath expression}&quot;/&gt;
</pre><img-text-block>The value of the select attribute of this element will be used as the files base for the document function with one parameter and for file storage with the xml-document element. Since version 1.5 it has no effect on the document function. It is an error if more than one xml-base element declared. Stylesheets with no xml-base element will use the base of the file passed trough the source parameter if any.
It is used for publishing purposes.</img-text-block><pre>&lt;!-- since 1.5 this element is no longer supported --&gt;
&lt;xsltp:http-output name=&quot;string&quot;&gt; template &lt;/xsltp:http-output&gt;
</pre><img-text-block>These elements set http headers. If they are absent then only Content-type: text/html will be output provided that the omit-http-headers attribute of the xsl:output element is not set to &quot;yes&quot;. These elements are instantiated with respect to the root node of the source document. Example of useful http field is the location field that can redirect a browser to the program output. The content of http-output is converted to string with the normalize-space function. The order of http fields output is the document order.</img-text-block><pre>&lt;!-- version &gt;=1.5 --&gt; 
&lt;http:headers&gt;
template
&lt;/http:headers&gt;
&lt;!-- the template must produce the list of elements --&gt;
&lt;http:field name=&quot;name of field&quot;&gt;its value&lt;/http:field&gt;</pre><img-text-block>The http:headers element can be used as an extension element provided that xmlns:http=&quot;#DOPS/Extensions/http.pm&quot; is set.</img-text-block><img-text-block><br/><ref file="doc/st_elements">What XSLT instructions does the parser support?</ref><br/><ref file="doc/func">What functions are implemented?</ref></img-text-block></html-page><html-page menu-item="Stylesheet elements" file="doc/st_elements"><head><title>XSLT stylesheet instruction elements</title><meta content="XSLT stylesheet instruction elements supported by CGI XSLT processor" name="Description"/><meta content="XSLT stylesheet instructions elements" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>XSLT stylesheet elements</b><br/><br/>CGI XSLT processor supports the following instructions</img-text-block><pre>xsl:apply-templates, xsl:attribute, xsl:call-template, xsl:choose, 
xsl:copy, xsl:copy-of, xsl:comment, xsl:element, xsl:for-each,
xsl:if, xsl:message, xsl:otherwise, xsl:param, xsl:sort, 
xsl:text, xsl:value-of, xsl:variable, xsl:when, xsl:with-param.
&lt;!-- version&gt;=1.5 --&gt;
xsl:processing-instruction
xsl:include for dynamical inclusion of stylesheets href must be a string, 
expressions are not supported
http:headers, http:field extension elements
</pre><img-text-block>The xsl:sort instruction is implemented with the default Perl sort function. Hence, language dependent sorting may be incorrect.<br/><br/>Not XSLT xml-document element controls the program output to the local disk. It must be a top node of the result tree or a top element of xsl:message. It is not an extension element. Executing stylesheet xsltp.pl XSLT processor treats this element as any literal element. A required attribute of the xml-document element is the system attribute. You can use the xsl:attribute instruction to set the system attribute. The content of the xml-document element will be saved in a file. The name of the file is defined by the system attribute value and by the xsltp:xml-base top element. Optional attributes are method=xml|html|text, omit-xml-declaration=&quot;yes&quot; and encoding (real encoding of the output, bytes or utf-8). The result tree root can have any number of the xml-document element children. Example</img-text-block><pre>&lt;xsl:tamplate match=&quot;/&quot;&gt;
&lt;html&gt;...&lt;/html&gt;
&lt;xml-document system=&quot;{myfile string expression}.xml&quot; method=&quot;xml&quot; encoding=&quot;bytes&quot;&gt;
...
&lt;/xml-document&gt;
&lt;/xsl:template&gt; 
</pre><img-text-block>Html element with its content will be output to STDOUT. Content of xml-document will be saved to the file.<br/><br/>The xsl:message instruction prints its content immediately without waiting the end of the transformation. The following example serves for an illustrative goal only.</img-text-block><pre>&lt;xsl:tamplate match=&quot;/&quot;&gt;
&lt;table&gt;
&lt;xsl:message&gt;
&lt;xsl:text disable-output-escaping=&quot;yes&quot;&gt; &lt;![CDATA[&lt;html&gt;&lt;body&gt;]]&gt; &lt;/xsl:text&gt;
&lt;/xsl:message&gt;
template calls here
&lt;/table&gt;
&lt;xsl:text disable-output-escaping=&quot;yes&quot;&gt; &lt;![CDATA[&lt;/html&gt;&lt;/body&gt;]]&gt;&lt;/xsl:text&gt;
&lt;/xsl:template&gt; 
</pre><img-text-block>The above code output is &lt;html&gt;&lt;body&gt;&lt;table&gt;.... In fact, you can omit xsl:text here, for xsltp.pl XSLT processor never escapes the text node children of the result tree root. The content of xsl:message is also treated as a result tree. It is worth mentioning that you can store the intermediate result tree in a file using combination of xsl:message and xml-document elements. After execution of the xsl:message block it is possible to load the intermediate result tree with the document function and continue the transformation.</img-text-block></html-page><html-page menu-item="Functions" file="doc/func"><head><title>XSLT functions</title><meta content="XSLT functions supported by xsltp.pl" name="Description"/><meta content="XSLT functions" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>XSLT functions</b><br/><br/>Xsltp.pl Perl XSLT parser supports the following functions</img-text-block><pre>boolean, concat, contains, count, current, document, 
false, file-name, last, gmtime, key, name, normalize-space, 
not, number, position, string, string-length, sum, 
system-property, starts-with, substring-after, substring-before, 
save-file, substring, time, true, translate.</pre><img-text-block>The system-property function is an interface to the environment variables. Examples, system-property( 'HTTP_ACCEPT_LANGUAGE'), system-property('DOCUMENT_ROOT') and so on. If a particular environment variable is undefined empty string is returned.<br/>The time function is a wrapper of Perl time function.<br/>The gmtime(integer expression?) function is a wrapper of Perl gmtime function. In node-set context, it returns the result tree fragment of the form</img-text-block><pre>&lt;year&gt;2004&lt;/year&gt;&lt;month&gt;1&lt;/month&gt;&lt;day&gt;28&lt;/day&gt;&lt;hours&gt;12&lt;/hours&gt;&lt;minutes&gt;30&lt;/minutes&gt;
&lt;seconds&gt;15&lt;/seconds&gt;&lt;weekday&gt;4&lt;/weekday&gt;&lt;yearday&gt;28&lt;/yearday&gt; </pre><img-text-block>(weekday ranges 1-7, month ranges 1-12, yearday ranges 1-365(366)). In scalar context, it returns string &quot;Wed Jan 28 12:30:15 2004&quot;. Example,</img-text-block><pre>&lt;xsl:template name=&quot;time&quot;&gt;
&lt;xsl:for-each select=&quot;gmtime(time()+3*3600)&quot;&gt;
&lt;xsl:value-of select=&quot;year&quot;/&gt;&lt;xsl:text&gt;-&lt;/xsl:text&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test=&quot;month&gt;9&quot;&gt;
&lt;xsl:value-of select=&quot;month&quot;/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select=&quot;concat(0,month)&quot;/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;&lt;xsl:text&gt;-&lt;/xsl:text&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test=&quot;day&gt;9&quot;&gt;
&lt;xsl:value-of select=&quot;day&quot;/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select=&quot;concat(0,day)&quot;/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test=&quot;hours&gt;9&quot;&gt;
&lt;xsl:value-of select=&quot;hours&quot;/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select=&quot;concat(0,hours)&quot;/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;&lt;xsl:text&gt;:&lt;/xsl:text&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test=&quot;minutes&gt;9&quot;&gt;
&lt;xsl:value-of select=&quot;minutes&quot;/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select=&quot;concat(0,minutes)&quot;/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;&lt;xsl:text&gt;:&lt;/xsl:text&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test=&quot;seconds&gt;9&quot;&gt;
&lt;xsl:value-of select=&quot;seconds&quot;/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:value-of select=&quot;concat(0,seconds)&quot;/&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;&lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre></html-page><html-page menu-item="Files upload" file="doc/upload"><head><title>Files upload</title><meta content="Filles upload in XSLT - save-file extention function" name="Description"/><meta content="xslt files upload save-file function" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>Files upload</b><br/><br/>Xsltp.pl CGI program supports files upload routines. To do file upload declare a global parameter of file type as</img-text-block><pre>&lt;xsl:param name=&quot;file&quot; as=&quot;file&quot;/&gt;</pre><img-text-block>Then, later in your code you can call the save-file function to store the file on the local disk. Example,</img-text-block><pre>&lt;xsl:if test=&quot;save-file($file, string expression)&quot;&gt;...&lt;/xsl:if&gt;</pre><img-text-block>Here, the string expression is the name of the new file (with path). The save-file function returns true if it succeeds and false if it fails. In scalar context, file variable is a string passed by a browser. It is an error if a new file cannot be opened for writing. The file-name function discards the file path and returns the file name file-name('c:\some\file.txt') returns 'file.txt'. The file extension you can get as substring-after(file-name($file),'.'). More precisely, the file-name function returns the string end consisting of alphanumeric characters, point, minus and underscore symbols. <br/><br/>Always check that the extension of the saved file is not xsl, since if some user can upload the file *.xsl this means that she/he can upload programs. Consequences are obvious.<b> Since version 1.5 the processor raises the error if the extension of the file is .xsl.</b><br/><br/>The safety of the file upload depends on the host configuration.</img-text-block></html-page></menu.items><menu.items title="Details"><html-page menu-item="Characters model" file="doc/chrsmodel"><head><title>Characters model</title><meta content="Characters model - One byte encodings in XML" name="Description"/><meta content="XML file encoding bytes nbsp character" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>Characters model</b><br/><br/>Perl XSLT parser xsltp.pl can use both unicode and bytes characters models. The default characters model is unicode. If your files are not utf-8 encoded you must have a proper *.enc file (see documentation of XML::Parser). To switch to bytes model use the following xml declaration</img-text-block><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;bytes&quot;?&gt;</pre><img-text-block>in all style files and in all xml document files.<br/><br/>With bytes characters model the actual encoding is left unchanged. The encoding of the program output will be the same as the encoding of your style and xml files. The use of character references is not allowed except &amp;quot;&amp;amp;&amp;apos;&amp;lt;&amp;gt;&amp;nbsp; standard references. In CDATA sections these references are replaced by the characters as well as in any text nodes. The nbsp character must be declared in the doctype section of the xml document (&lt;!DOCTYPE xml [&lt;!ENTITY nbsp &quot;&amp;#160;&quot;&gt;]&gt;) Any byte in the data and the style files will be considered as a legal character.<br/><br/>At present, it is known that in Perl 5.6.1 the program may output unicode strings incorrectly. If you wish to use unicode characters it is strongly recommended to update your version of Perl to 5.8. The first version of Perl with thorough Unicode support.</img-text-block></html-page><html-page menu-item="Data types" file="doc/datatypes"><head><title>Data Types</title><meta content="XPath Data Types in CGI XSLT processor" name="Description"/><meta content="xpath data types" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>XPath Data Types</b><br/><br/>Xsltp.pl Perl XSLT parser has no number type and string type. Strings and numbers are scalars. This is why the following declarations of the variable are all identical</img-text-block><pre>&lt;xsl:variable name=&quot;var&quot; select=&quot;'2'&quot;/&gt;
&lt;xsl:variable name=&quot;var&quot; select=&quot;2&quot;/&gt;
&lt;xsl:variable name=&quot;var&quot;&gt;2&lt;/xsl:variable&gt;</pre><img-text-block>You may think about numbers of this processor as XSLT 1.0 strings, which are internally converted to numbers when this is necessary. XPath number(...) function returns NaN if a scalar is not a number. XPATH string(...) function does nothing with numbers. Boolean type is context dependent. This means that there are no boolean variables (if you define one with boolean expression it will be equal to scalar 1 or 0). However, when xsltp.pl XSLT parser sees a boolean expression the program processes it correctly and converts scalars and node-sets to boolean type. All predicates are evaluated as boolean expressions. Hence, element[$var] is a node-set consisting of all element children of the current node while element[$var=position()] is the second element child of the current node. Result tree fragment variable is always converted to a node-set consisting of just a root node. You can use step operators with result tree fragment variables. Here is an example.</img-text-block><pre>&lt;xsl:variable name=&quot;time&quot;&gt;&lt;year&gt;2003&lt;/year&gt;
&lt;month&gt;12&lt;/month&gt;...&lt;/xsl:variable&gt;</pre><img-text-block>Then expression string($time/month) is equal to 12.<br/><br/>With global parameters var1 and var2 you can write name[$var1]/childname[$var2] for $var2 childname element of $var1 child name element of the current node provided that $var1 and $var2 are positive integers. Never use negative integers as element indexes. Declare the global parameter, which is passed to the stylesheet and is used as index, with type unsigned-int.<br/><br/>Remark. Strictly speaking, XML has two data types: strings and nodes (data objects), while XPATH 1.0 has expression types and no data types.</img-text-block></html-page><html-page menu-item="Result tree fragments" file="doc/restreefrg"><head><title>XSLT result tree fragments</title><meta content="Remarks on XSLT result tree fragments" name="Description"/><meta content="XSLT result tree fragment" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>Result tree fragments</b><br/><br/>Xsltp.pl Perl XSLT processor converts all result tree fragments to node-sets. Empty result tree fragment is converted to empty node-set (not empty string). This method does not lead to any kind of problems and also eliminates the necessity of the following trick for empty node-set declaration</img-text-block><pre>&lt;xsl:variable name=&quot;some&quot; select=&quot;/..&quot;/&gt;</pre><img-text-block>The result tree fragment with content is converted to the node-set consisting of just a root node of the result tree fragment. You won't encounter any problems with existing XSLT programs since the node-set is converted to string exactly as it is required.<br/><br/>The following code fragment</img-text-block><pre>&lt;xsl:apply-templates select=&quot;$treefragment&quot;/&gt;</pre><img-text-block>results always in infinite loop! It is true for any XSLT parser. You must use either the mode attribute or select a particular element of the tree fragment, e. g</img-text-block><pre>&lt;xsl:apply-templates select=&quot;$treefragment/someelement&quot;/&gt;</pre></html-page><html-page menu-item="Variables scope" file="doc/varsscope"><head><title>Scope of XSLT variables and parameters </title><meta content="Scope of XSLT variables and parameters in CGI XSLT processor" name="Description"/><meta content="XSLT variables and parameters" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>Variables and parameters scope</b><br/><br/>The local variable (parameter) declared is visible until the end of the block. Any template called after the variable declaration will see this variable. In particular, if the variable is defined in the entry point of the stylesheet (template with match=&quot;/&quot;) you can refer to it in any template. Technically, the variable stack is not created for each template. Of course, you can overwrite the value of the variable at any place of the stylesheet. Its old value will be restored after the end of the block. This method was found to be useful and safe since Stylesheet Language XSLT has no assignment operator and XSLT program cannot damage the variable.</img-text-block></html-page><html-page menu-item="Conflict resolution" file="doc/conflict"><head><title>Method for conflict resolution of templates rules</title><meta content="Method for conflict resolution of templates rules in XSLT" name="Description"/><meta content="method for XSLT templates rules conflict resolution" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>Method for conflict resolution of templates rules</b><br/><br/>Xsltp.pl Perl XSLT parser does not support the priority attribute of template elements. Instead, the following pattern ordering algorithm is applied to resolve template rules conflicts.<br/><br/>The order of pattern, by definition, is the number of step operators, e. g. Order(x/*/z)=Order(x//*/z)=Order(//x/z)=Order(*//*/*)=2. Absolute paths are treated as paths, which begin with the fictitious name &quot;root&quot;. The pattern path1 has always higher priority than pattern path2 if Order(path1)&gt;Order(path2). Each pattern in the set of patterns with the same order is decomposed as path=...('/'|'//')p1('/'|'//')p0 where p1 and p0 have no step operators. Patterns with p0!='*'|'@*' have the highest priority. The program, then, will consider patterns with p1!='*', then it will study patterns of the form ...p1/p0 and then it will analyze patterns of the form ...p1//p0. If the conflict is not resolved the above rule is used with respect to the next left step pattern ...p2('/'|'//')p1... At each step the set of patterns with higher priority can have no suitable pattern for the current node. If it happens the set with previous priority is considered and so on. Example,</img-text-block><pre>* &lt; x &lt; *//* &lt; */* &lt; a//* &lt; b/* &lt; *//x &lt; */x &lt; a//x &lt; b/x &lt; */*/*</pre><img-text-block><br/>A pattern can have only one predicate. Pattern with predicate has higher priority than pattern with no predicate (x[expression]&gt;x). If more than one pattern with predicate is defined the first found pattern, predicate of which is evaluated to true, will be selected. Templates have inverse order to the document order.<br/><br/>Remark. Pattern of the form x[cond1][cond2] can be replaced by x[cond1 and cond2].</img-text-block></html-page><html-page menu-item="The key function" file="doc/keyfunc"><head><title>XSLT key function</title><meta content="XSLT key function imlementation,example and usage" name="Description"/><meta content="XSLT key function example usage" name="Keywords"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>XSLT key function</b><br/><br/>Xsltp.pl Perl XSLT processor initializes the key function when it encounters the first call of the key function. It is instantiated with respect to the root node of the current document. If the current document is changed the instantiated key function will store the nodes of the previous document. The match attribute value of the key function is either a pattern or a node-set expression (not only a pattern). The use attribute value of the XSLT key function is any expression. The algorithm works as follows. If the value of the match attribute is a pattern (or a relative path) it is first converted to absolute path expression (x-&gt;//x). The expression is evaluated to construct the node-set. The use attribute is evaluated for each node in the node-set. The obtained values are used as the keys. Notice that the XSLT key function is efficient only when you employ it repeatedly.<br/><br/>Examples. Replacement of the id function</img-text-block><pre>&lt;xsl:key name=&quot;id&quot; match=&quot;*&quot; use=&quot;@id&quot;/&gt;</pre><img-text-block>Array of elements</img-text-block><pre>&lt;xsl:key name=&quot;array&quot; match=&quot;name&quot; use=&quot;position()&quot;/&gt;</pre><img-text-block>key('array',2) is the second name element of the document. Index for words
</img-text-block><pre>&lt;xsl:key name=&quot;index&quot; match=&quot;name&quot; use=&quot;contains(.,'word')&quot;/&gt; </pre><img-text-block>key('index', true()) is the node-set of name elements with string value containing the word &quot;word&quot;. The following code is also legal,</img-text-block><pre>&lt;xsl:key name=&quot;name1&quot; match=&quot;$x/someelement&quot; use=&quot;some expression&quot;/&gt;</pre><img-text-block>Here, $x (global variable) is eather the node-set or the result tree fragment. And even this code</img-text-block><pre>&lt;xsl:key name=&quot;name2&quot; match=&quot;key('array',2)/someelement&quot; use=&quot;some expression&quot;/&gt;</pre><img-text-block>is allowed.<br/><br/>Usage example. Let we have a list of books, something like this</img-text-block><pre>&lt;books&gt;
&lt;book&gt;
&lt;title&gt;...&lt;/title&gt;
&lt;author&gt;...&lt;/author&gt;
&lt;author&gt;...&lt;/author&gt;
&lt;author&gt;...&lt;/author&gt;
&lt;/book&gt;
....
&lt;/books&gt;,</pre><img-text-block>and wish to have a list of publications of each author. The following key function solves the problem</img-text-block><pre>&lt;xsl:key name=&quot;books_of_author&quot; match=&quot;book&quot; use=&quot;author&quot;/&gt;</pre><img-text-block>provided that we know a way how to create the distinct list of authors. Here it is</img-text-block><pre>&lt;xsl:template match=&quot;books&quot;&gt;
&lt;authors-list&gt;
&lt;xsl:for-each select=&quot;book/author [self::author!=../following-sibling::book/author]&quot;&gt;
&lt;author&gt;
&lt;name&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/name&gt;
&lt;xsl:for-each select=&quot;key('books_of_author',.)&quot;&gt;
&lt;book-title&gt;&lt;xsl:value-of select=&quot;title&quot;/&gt;&lt;/book-title&gt;
&lt;/xsl:for-each&gt;
&lt;/author&gt;
&lt;/xsl:for-each&gt;
&lt;/authors-list&gt;
&lt;/xsl:template&gt;</pre><img-text-block><br/>Remark. Since we cannot get keys of the key function in XSLT, the above code is not efficient. The distinct list of authors is created two times here. First time, when the key function is initialized (with sorting algorithm) and, second time, when the distinct list itself is constructed in the XSLT code (without sorting algorithm).</img-text-block></html-page><html-page menu-item="The document function" file="doc/document_function"><head><title>The document function of CGI XSLT processor</title><meta content="Usage of the document function in CGI XSLT processor" name="Description"/><meta content="XSLT document function" name="Keywords"/></head><img-text-block><b>The XSLT document function</b><br/><br/>Xsltp.pl XSLT engine implemets the document function in a context independent way. It is simpler than sophisticated XSLT 1.0 document function. The function has the type  </img-text-block><pre>node-set  document(object,object?)</pre><img-text-block>The first argument is the file name, and the second argument is the file base (&quot;base URI&quot;). If one or both are node-sets then a node-set of root nodes of documents is returned. Examples,</img-text-block><pre>&lt;!-- if xsltp:xml-base is not set the first function is   --&gt; 
&lt;!-- equivalent to the document function with one argument --&gt; 
document('my.xml',$source)
document('my.xml',$style)</pre><img-text-block>The first document function loads the my.xml document from the same directory as the source file, the second, from the same directory as the style file. The document function with two arguments doesn't depend on the file names (&quot;URI&quot;) of the XSLT stylesheet or XML source.<br/><br/>In version 1.5 one argument document function behavior has been changed. If the argument is a node-set then the string value of each node is used as a file name and the path of the node document is used as the file base. The processor returns the union of ducuments. If the argument is a string it is used as a file name with the location of XSLT stylesheet being the file base.    <br/><br/></img-text-block><img-text-block>Remark (v1.0 only). If the XSLT stylesheet employs the document function with one argument in the context of the XML source document (e. g. document(@file)) then the document function of the xsltp.pl XSLT processor is identical to XSLT 1.0 document function. If it is used in the XSLT stylesheet context then XSLT 1.0 document function is identical to document('my.xml',$style).</img-text-block></html-page><html-page menu-item="Curly brackets in attributes" file="doc/curlybr"><head><title>Curly brackets in attribute values</title><meta content="Curly brackets in attribute values" name="Description"/><meta content="G. Varzugin" name="Author"/></head><img-text-block><b>Curly brackets in attribute values</b><br/><br/>Declare the following XSLT stylesheet parameters</img-text-block><pre>&lt;xsl:param name=&quot;cbl&quot; select=&quot;'{'&quot;/&gt;
&lt;xsl:param name=&quot;cbr&quot; select=&quot;'}'&quot;/&gt;</pre><img-text-block>Then you can use them with the concat function. Example,</img-text-block><pre>&lt;BODY bgcolor=&quot;&amp;amp;{concat($cbl,'randomrbg',$cbr)};&quot;&gt;...&lt;/BODY&gt;</pre><img-text-block>Alternatively, you can employ the xsl:attribute element. The use of literal strings which contain { and (or) } characters in the attribute values is not permitted. Xsltp.pl XSLT parser does not support the method of &quot;double bracket&quot;.</img-text-block></html-page></menu.items><menu.items title="Extensions"><html-page file="doc/xslt_perl_extension" menu-item="Extension modules"><head><title>Extension elements and functions of XSLT processor</title><meta name="Description" content="Design of extension elements and functions for XSLT processor"/><meta name="Keywords" content="XSLT extension elements functions"/><meta name="Author" content="G. Varzugin"/></head><img-text-block><b>Extension elements and functions</b><br/><br/>The extension instructions are loaded in the namespace of XSLT package. We design XSLT package in procedural style. The XSL instruction is a Perl function that has the name of XML element with symbols ':' and '-' replaced by underscore symbol '_'. The processor executes it at compile time. The extension function must return the reference to the function that will do the real job. The name prefix is required.</img-text-block><pre>package XSLT;
use strict;
my $local_var='';
$XSLT::global_var='';

sub prefix_top_element {
my $xslt_top_node=shift;
#initialize variables
$local_var='hello';
$XSLT::global_var='world';
#prevent execution of the top instruction in the XSLT code
return \&amp;_do_nothing;
}

sub prefix_instruction_name {
my $xslt_tree_node=shift;
#compilation code here
return \&amp;_prefix_instruction_name;
}

sub _prefix_instruction_name {
my ($xslt_tree_node,$xml_source_current_node,$result_tree_node)=@_;
#execution code
}

sub prefix_FINISH {
#reinit variables here for compatibility with mod_perl
$local_var='';
$XSLT::global_var='';
#do not use exit or die!
#this function is not required
}
1;</pre><img-text-block>All variables with the word &quot;node&quot; in their names are objects of XMLTree class.<br/><br/>The extension functions are loaded in the namespace of XPath::Expression package designed in object oriented style. The function is the method of XPath::Expression class that has the name of the extension function with ':' and '-' replaced by '_'. The name prefix is recommended.</img-text-block><pre>package XPath::Expression;
use strict;

sub prefix_function_name {
my ($expr,$current_node,$retern_type)=@_;
my $args=$expr-&gt;{arg} || die &quot;the function needs arguments&quot;;
# $args is a ref to array of XPath::Expression objects

#the evaluate method return the result as it is
my @evaled_args=map{$_-&gt;evaluate($current_node)} @{$args};

#the string method converts the result to scalar type 
my @evaled_string_args=map{$_-&gt;string($current_node)} @{$args};

#wish to retun a scalar
return $my_scalar_var;

#wish to return a result tree fragment
my $new_tree=$current_node-&gt;newroot();
#create tree code
#convert it to node-set
my $ns=[$new_tree];
#evaluate step operators and conditions if they are present
return $expr-&gt;proceed($ns);  
}
1;</pre><img-text-block>The parameter $return_type indicates the context of the extension function. It is needed only if you want to create the function return value of which depends on the expression context. Example is the gmtime function built in the XSLT processor.<br/><br/>Declarations of extension instructions and functions can be placed in the same file. The XSLT stylesheet loads it as follows  </img-text-block><pre>&lt;xsl:stylesheet xmlns:prefix=&quot;#path-to-module/my-module.pm&quot;&gt;
....
&lt;/xsl:stylesheet&gt;</pre><img-text-block><br/><b>Functions used for compilation of XSLT elements</b><br/><br/>The attributes of XSLT instruction can be attribute templates and XPath expressions. Both types require compilation.</img-text-block><pre>sub prefix_instruction {
my $xslt_element=shift;
$atr=$xslt_element-&gt;getAttribute('name-of-it');
#logic for error handling die if it is critical
$xslt_element-&gt;{prefix_compiled_value}=compile_attr_expr($atr);

$xatr=$xslt_element-&gt;getAttribute('xpath-attr');
$xslt_element-&gt;{prefix_compiled_xpath}=XPath::Expression-&gt;parse($xatr)||die $XPath::Vars::Error;

#code
return \&amp;_prefix_instruction;
}

sub _prefix_instruction {
my ($xslt_element,$xml_source_current_node,$result_tree_node)=@_;

my $atr=$xslt_element-&gt;{prefix_compiled_value};
#get value
my $atrval=eval_attr_expr($atr,$xml_source_current_node);

my $xp=$xslt_element-&gt;{prefix_compiled_xpath};
my $xpresult=$xp-&gt;evaluate($xml_source_current_node);

#create new tree fragment example
my $newtree=$xml_source_current_node-&gt;newroot();
if(ref($xpresult)) { #check that we have node-set
foreach my $n (@{$xpresult}){
eval_template($xslt_element,$n,$newtree);
}
}

#analize $newtree

#print something to result tree
$result_tree_node-&gt;newchild('test')-&gt;newtext($atrval);
}</pre></html-page><html-page menu-item="XSL message handlers" file="doc/xsl_message_handling"><head><title>Sending messages to programs with XSLT prosessor</title></head><img-text-block><b>Sending messages to programs with XSLT prosessor</b><br/><br/>The xsl message handler is a package that opens a channel for the XSLT processor output.   </img-text-block><pre>package MyMessage::Send;
use strict;

sub message_handler {
my ($msg,$params)=@_;

open my $fh, &quot;|/usr/lib/sendmail -oi -t&quot; or die &quot;could not open&quot;;

#print some headers

#print message
$msg-&gt;print_html($fh);#or print_xml or print_text
#html, xml or text state for the print method of XSLT

# or use the print method of XSL stylesheet
XSLT::printResultTree($fh,$msg);

#get text data of $msg XML tree
$msgstr=$msg-&gt;string();
close($fh); 
}
1;</pre><img-text-block>The stylesheet can now use the xsl:message element to send the message.</img-text-block><pre>&lt;xsl:message msg-handler=&quot;MyMessage::Send&quot; To=&quot;Destination &amp;lt;{xpath expression}&amp;gt;&quot;
From=&quot;User Mail &amp;lt;me@host&amp;gt;&quot;
Subject=&quot;subject line&quot;&gt;

template for $msg

&lt;/xsl:message&gt;
</pre><img-text-block>The variable $params is a reference to hash of xsl:message attributes. The attribute values are first evaluated by the XSLT processor as attribute templates except values of msg-handler and terminate.  </img-text-block></html-page><html-page menu-item="XML tree class" file="doc/xml_tree_class"><head><title>XML tree class</title></head><img-text-block><b>XML Tree class</b><br/><br/>XMLTree class constructors </img-text-block><pre>my $newroot=$n-&gt;newroot(); #create a new root node

#add element to XML tree
my $element_added=$newroot-&gt;newchild('element-name');

#create attribute of &quot;element-name&quot; element
my $attribute_added=$element_added-&gt;newattribute('name','value');

#add text node to children of &quot;element-name&quot;
my $text_added=$element_added-&gt;newtext('string value');

#add PCDATA element
$element_added-&gt;newchild('name')-&gt;newtext('string'); #chain rule

#copy works as xsl:copy
$element_added-&gt;copy($somenode);

#copy_of works as xsl:copy-of
$element_added-&gt;copy_of($somenode);</pre><img-text-block>XMLTree class methods</img-text-block><pre>my $chs=$n-&gt;children(); #get node-set of childern nodes of element
my $attrs=$n-&gt;attributes(); #get node-set of attributes of element
my $p=$n-&gt;parent(); #get parent of element undef is returned if $n is a root node

my $str=$n-&gt;string(); #get text data of node
my $name=$n-&gt;name(); #get name of node undef is returned for text nodes
#get value of attribute of element ($n is element)
#if not exist undef is returned
my $aval=$n-&gt;getAttribute('name-of-it');

$n-&gt;type()&gt;=0 #the node is element
$n-&gt;type()==-1 #the node is a text node
$n-&gt;type()==-2 #the node is an attribute node

#methods for printing $fh is any object that has the method print IO::File is assumed
$n-&gt;print_xml($fh); $n-&gt;print_html($fh); $n-&gt;print_text($fh);</pre><img-text-block><br/>Node-set is a reference to array of XMLTree  objects. The class was designed for creation of XML documents. XPath::Expression class builds node-sets.</img-text-block><pre>my $xp=XPath::Expression-&gt;parse('my expression')||die $XPath::Vars::Error; #compile one
my $ns=$xp-&gt;evaluate($n); # execute it with respect to the node, $n - current node
#$xp-&gt;string($n) execute and convert to string
#$xp-&gt;boolean($n) execute and convert to boolean

if(ref($ns)){
#$ns is a node-set, process the result
foreach my $n (@{$ns}){
#code
}
}else{
#$ns is a scalar
}</pre></html-page></menu.items></pages-div><pages-div><html-page menu-item="Website Editor" file="wcx_editor/edit_website"><head><title>Editing the web site content with WCX Editor-WebSite manager</title><meta name="Description" content="WCX Editor - tool to manage, maintain and edit websites"/><meta name="Keywords" content="website content editor manager"/></head><img-text-block><b>WCX Editor is a tool for web site content editing  </b>intended to be used by the person who wants to make the web site <i>updates, changes, revises and renewals </i> with easy-to-use server-side Web Site Manager. The site manager will let you do<ul><li>Manage a whole site at once from anywhere in the world keeping your web site up to date with fresh content by adding new pages, images or text  
</li><li>Create the web site HTML pages with search engine friendly names, title, key words and description publishing the changes yourself </li><li>Maintain the web site pages content with consistent look and feel with pre-built templates that are created to support the site design</li><li>Integrate custom designs and functions that distinguish your web site</li><li>Extend functionality, in the future, when you'll start to think that something is missing</li></ul><img src="/images/patc.jpeg" align="left" alt="Edit web site easily"/>The Web Editor controls and maintains the web site as a whole data structure. Optionally, it is possible to create an independent section supported by the Web Manager. The pages that are not inside it will be out of the control of the system.<br/><br/>The Editor has no tool bar menu. Its controllers are html links. Pressing these links the user changes the state of the editor and activates additional link-like menus. Navigating over the web site the user selects the website page to edit then the object to be modified or the create object link-controller to insert a new one.<br/><br/>Each copy of the WCX Editor is specifically tailored with the features and editing functions the site requires. The web editor is built with XSLT stylesheets by the web developer who provides solutions for the web site, integrating designs and functions. Demo version can be found <ref file="website_content_editor">here</ref></img-text-block></html-page><menu.items title="Genaral"><html-page menu-item="Installation" file="wcx_editor/intallation"><head><title>Installation of WCX Editor</title></head><img-text-block><b>Installation</b><ul><li>Download the CGI XSLT processor and copy CGIXSLT.pm, bytes.enc, xsltp.pl into your cgi-bin directory. Rename xsltp.pl to xsltp.cgi if it is necessary.</li><li>In cgi-bin directory create a directory for WCXE files (default wcxe; 750 recommended). Copy all files there.</li><li>Open &quot;glob_params.xsl&quot; and set parameters following the comments.</li><li>Examples of how to call the WCX Editor are in edit.html file.</li><li>File empty.xml is an empty data file of WCX Editor. You can rename and copy it to any directory. This directory must have html subdirectory used for html code storage.</li><li>The utf-8 copy of the wcxe files is in utf8 directory. You can use either one byte encodings or utf-8 encoding but not both. Utf-8 version of the editor had the bug that was corrected 30 January 2005. </li></ul></img-text-block></html-page><html-page menu-item="Password protection" file="wcx_editor/session_id_parameter"><head><title>Protection of XSLT stylesheets with session id parameter</title><meta content="A method for password protection of XSLT stylesheets with session id parameter" name="Description"/><meta content="session id parameter XSLT stylesheet" name="Keywords"/></head><img-text-block><b>Password protection of XSLT stylesheets with session id parameter</b><br/><br/>CGI XSLT engine reads HTTP COOKIE. This feature can be used for password protection of XSLT programs. We assume that you know how to set HTTP COOKIE. Here, we explain a method how the session parameter can be passed to xsltp.pl Perl script.<br/><br/>It is convenient to create the XML file (not use .xml extesion in file names for session parameters)</img-text-block><pre>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE session-param [&lt;!ENTITY session_id SYSTEM &quot;my_session_file_name&quot;&gt;]&gt;
&lt;session_id&gt;&amp;session_id;&lt;/session_id&gt;</pre><img-text-block>Then, declare the session parameter and session variable in the XSLT stylesheet </img-text-block><pre>&lt;!-- string or int or number type --&gt;
&lt;xsl:param name=&quot;my_session_param&quot; as=&quot;string&quot; max-size=&quot;10&quot;/&gt;
&lt;!-- session variable --&gt;
&lt;xsl:variable name=&quot;session&quot;&gt;
&lt;xsl:choose&gt;
&lt;xsl:when test=&quot;$my_session_param=document('name_of_above_file',$source)/session_id&quot;&gt;
&lt;xsl:value-of select=&quot;$my_session_param&quot;/&gt;
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;xsl:message terminate=&quot;yes&quot;&gt;
&lt;html&gt;
&lt;body&gt;.... &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:message&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:variable&gt;</pre><img-text-block>The script that sets &quot;my_session_param&quot; value in HTTP COOKIE saves the session id parameter in the file &quot;my_session_file_name&quot;. In the above code it was assumed that the file &quot;name_of_above_file&quot; is in the same directory as the XML source. If this is not the case the document function can be called with different second argument.<br/><br/>As concerns WCX Editor, it is enough to protect the &quot;xe_main&quot; XSLT stylesheet.</img-text-block></html-page></menu.items><menu.items><menu-div><html-page menu-item="User's Guide" file="wcx_editor/user_guide"><img-text-block><b>The Page and Content menus</b><br/><br/>The page and content menus are the main menus of the WCX Editor. The page menu serves for creation of the html pages. All pages are organized into menu items. The menu items are divided in the menu blocks. The content menu displays the list of new objects you can insert and the list of actions you can do with the object. Using the WCX Editor you do not edit html code. You edit the object properties. The object can be just the description of the product or the collection of items used often like lists, links, images and so on.  </img-text-block><head><title>The page and content menus of the WCX Editor</title></head></html-page><popup-items><html-page menu-item="The page menu" file="wcx_editor/page_menu"><head><title>The page menu of the WCX Editor</title></head><img-text-block><b>The page menu of the website Editor</b><br/><br/><i>New page - </i>create a new page of the web site. In the HTML form appeared, type the item name that will be shown in the menu and the file name to use when the page will be published. The file name can be &quot;my-dir/my-page-file&quot;. The &quot;my-dir&quot; directory must exist. HTML extension will be added automatically(do not set it). The web editor has four options for the menu. With the first and second it creates the web page as top menu item. With the last two it builds the web page as left menu item. <br/><br/><i>Page meta - </i>set the meta data of HTML page: title, description and key words.  <br/><br/><i>File and Item names - </i>reset the menu item name and file properties of the HTML page.<br/><br/><i>List of pages - </i>list all website pages.<br/><br/><i>New block - </i>create a new menu block of items.<br/><br/><i>Hide controllers - </i>don't display the object link-controllers.<br/><br/><i>Menu block up - </i>move the current menu block position up.<br/><br/><i>Item up - </i>move the current menu item position up.<br/><br/><i>Publish page - </i>publish the current page of the web site.<br/><br/><i>Publish all - </i>publish all pages of the web site. Use it if you add, delete or reorganize pages of the web site.<br/><br/><i>Delete - </i>delete the current page. If the page has been published its local disk copy is not deleted. You can not delete the page if some other pages have the links to it.</img-text-block></html-page><html-page menu-item="The content menu" file="wcx_editor/content_menu"><head><title>The content menu of the WCX Editor</title></head><img-text-block><b>The content menu of the website Editor</b><br/><br/>The content menu is hierarchical. Its content depends on the active object. The upper level is the menu for the creation of objects. The following objects are installed in freely distributed package<br/><i>Image-text block - </i>a universal purpose object for lists, links, images and text.<br/><i>Preformatted text - </i>an example of an object that is special for dopscripts.com web site<br/><i>HTML code - </i>an object for insertion of html code. The code is prepared outside the application.<br/><br/>Image-text block object holds<ul><li>Bold, italic and normal text</li><li>Line breaks</li><li>Internal links</li><li>External links</li><li>Images</li><li>Lists like this one</li></ul>Links, images and lists have their own menus as well. </img-text-block></html-page><html-page menu-item="Images" file="wcx_editor/images"><head><title>Uploading images with WCX Editor</title></head><img-text-block><b>Inserting images</b><br/><br/>The html form for uploading images has the file field, selected with the browse button, and file name text field. At least one of them must be filled.<br/><br/>If the name field is empty then the file name passed by a browser will be used for the image storage. It is guaranteed that neither of the images that have been uploaded with WCX Editor and are still in use will be overwritten.<br/><br/>If the name field is not empty its value is used for file name of the image. The file extension must be set. If the image with the name passed exists it will be overwritten. The default directory can be redefined with absolute path syntax e. g. /my-dir/my.jpg. Recall, when the image is overwritten the old one is in the browser cache. Press back link in the menu and then refresh the page to update it.<br/><br/>If only the name field is set then the program assumes that the image is already on the web site. WCX Editor does not check whether the file exists or not. You will see it yourself.</img-text-block></html-page></popup-items></menu-div><menu-div><html-page menu-item="Designer's Cuide" file="wcx_editor/designer_guide"><head><title>Installation of the web site design in WCX Editor</title></head><img-text-block><b>Website Design Installation</b><br/><br/>The XSLT stylesheet &quot;site_glob&quot; is the point to start website design editing. It defines the html code common for all pages. There, find the template with the match attribute value equals &quot;html-page&quot;. This template sets the global structure of the web site. HTML head element is handled automatically except that you need to add the link tag to load the CSS files.<br/><br/>The XSLT templates with names &quot;top-of-page&quot; and &quot;bottom-of-page&quot; hold html code common for all pages. Place your own code there. The table that you find in the template with match=&quot;html-page&quot; sets the layout of the web site. We employ two-area model. Template with name &quot;menu-block&quot; fills the left area. The XSLT template with name &quot;center-block&quot; controls the right area.<br/><br/>Installation of the top menu is a little trickier. Our system for web site editing supports user defined top items and page-selected event. The template with name &quot;create-top-menu&quot; prints the top menu of the web site. Let the user wish to edit the top items of the web site. The template mentioned above handles four cases, namely,<br/>1. the page is selected and is the first one<br/>2. the page is selected and is not the first one<br/>3. the page is not selected and is the first one<br/>4. the page is not selected and is not the first one<br/>Provide the code for these four events and rest a little. The installation is not finished.<br/><br/>The user does not want to edit the web site top items. Then, you need to create the top items by yourself before you can proceed with installation. There are two kinds of top items. They are divided into groups. The pages in each group share the left area. Make your chose. Remember the file property of each page. We will process each item manually as follows. </img-text-block><pre>&lt;xsl:for-each select=&quot;$top_pages[@file='file_name']&quot;&gt;
&lt;xsl:choose&gt;
&lt;!-- page not selected --&gt;
&lt;xsl:when test=&quot;not(@file=$current-page)&quot;&gt;
&lt;!-- html code --&gt;
&lt;/xsl:when&gt;
&lt;!-- page selected --&gt;
&lt;xsl:otherwise&gt;
&lt;!-- html code --&gt;
&lt;/xsl:otherwise&gt;
&lt;xsl:choose&gt;
&lt;/xsl:for-each&gt;
&lt;!-- repeat for each item --&gt;</pre><img-text-block>Do not set the href attribute manually. Use WCXE template. Example,</img-text-block><pre>&lt;a class=&quot;some&quot;&gt;&lt;xsl:call-template name=&quot;href-attribute&quot;/&gt;
&lt;!-- image or text --&gt;
&lt;/a&gt;</pre><img-text-block>It is still possible to create the &quot;top items&quot; but they become hidden. However, these hidden html pages of the web site can be reached with internal reference mechanism.</img-text-block></html-page><popup-items><html-page menu-item="Menu items design" file="wcx_editor/menu_items_design"><head><title>Templates for website menu items </title></head><img-text-block><b>Website menus design</b><br/><br/>We map all html pages of the web site into menu items. Website menu items are devided in blocks. There are two types of munu items the normal items and the menus with pop up items.  <br/><br/>The site_left_area XSLT stylesheet sets the layout of the website menus and defines menu items design. The XSLT template with match=&quot;menu.items&quot; sets the layout of the menu blocks. The block can hold either normal items or menus with pop up items.<br/><br/>The XSLT template with match=&quot;menu.items/html-page&quot; sets the layout of the normal menu item. The XSLT template with &quot;name=menu:item_ref&quot; handles the page-selected event and prints the item.<br/><br/>The XSLT template with match=&quot;menu.items/menu-div&quot; implements the logic of the menus with pop up items. The model is event based. The menu is active if either it or one of its item have been selected by the user. It is also essential to keep trace of the item position. <br/>1. The XSLT template with name=&quot;menu:pop_up_middle&quot; takes the control if the menu is not the last and is not active.<br/>2. The XSLT template with name=&quot;menu:pop_up_last&quot; is excuted if the menu is the last item in the block and it is not active.<br/>3. The XSLT template with name=&quot;menu:pop_up_last:active&quot; is evaluated if the menu is active and has pop up items or has no pop up items and is the last and active.<br/>4. The XSLT template with name=&quot;menu:pop_up_middle:active&quot; starts running if the menu has no pop up items and is active.<br/><br/>The XSLT templates with names &quot;menu:pop_up_item&quot; and &quot;menu:pop_up_item_last&quot; set the layout of pop up items. The XSLT template with name=&quot;menu:pop_up_item_ref&quot; handles the page-selected event and prints the item.</img-text-block></html-page><html-page menu-item="Page content design" file="wcx_editor/page_content_design"><head><title>Web page content design</title></head><img-text-block><b>Web page content design</b><br/><br/>The XSLT stylesheet &quot;site_center_area&quot; defines the rules for mapping the WCXE objects into html code of the website page. If the object has been setup its html code representation is the easiest part of the installation. There are two XSLT templates for each object in the XSLT stylesheet &quot;site_center_area&quot;.<br/><br/>For a top object of html-page the following XSLT templates must be designed</img-text-block><pre>&lt;xsl:template match=&quot;object-name[position()=$obj.active]&quot; mode=&quot;content-of-page&quot;&gt;
...
&lt;/xsl:template&gt;
&lt;xsl:template match=&quot;object-name&quot; mode=&quot;content-of-page&quot;&gt;
...
&lt;/xsl:template&gt;
</pre><img-text-block>The first XSLT template is excuted when the user selects the object for editing. The second displays the object and the WCX Editor link-controller. The link-controller is printed by the XSLT template with name &quot;xe:controller&quot;. The top object can be a collection of other objects. Then, the object-selected event is propagated to its child objects. The child objects are handled by the templates</img-text-block><pre>&lt;xsl:template match=&quot;object-name&quot; mode=&quot;content-of-page&quot;&gt;
...
&lt;/xsl:template&gt;
&lt;xsl:template match=&quot;object-name&quot; mode=&quot;select-objects&quot;&gt;
...
&lt;/xsl:template&gt;</pre></html-page><html-page menu-item="HTML code insertion" file="wcx_editor/html_code"><head><title>Inserting HTML code</title></head><img-text-block><b>HTML code</b><br/><br/>To insert html code prepare the XML file of the following type</img-text-block><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;bytes&quot;?&gt;
&lt;html-code&gt;
&lt;!-- html elements here --&gt;
&lt;/html-code&gt; </pre><img-text-block>Then, upload the code into the desired page. You must use XML syntax for empty HTML elements e. g. &lt;br&gt; --&gt; &lt;br/&gt;, &lt;img src=&quot;...&quot;&gt; --&gt; &lt;img src=&quot;...&quot;/&gt; and so on. </img-text-block></html-page></popup-items></menu-div><menu-div><html-page menu-item="Developer's Guide" file="wcx_editor/developer_guide"><head><title>Markup elements of WCX Editor</title></head><img-text-block><b>Markup elements</b><br/><br/>There are two groups of markup elements. The first group serves for division of the web site pages. The second serves for definition of the content of the page. Markup elements for pages division are</img-text-block><pre>&lt;!ELEMENT site-map (pages-div+)&gt;
&lt;!ELEMENT pages-div (html-page*,menu.items*)&gt;
&lt;!ATTLIST html-page file ID #REQUIRED&gt;
&lt;!ATTLIST html-page menu-item CDATA #REQUIRED&gt;
&lt;!ELEMENT menu.items (html-page+|menu-div+)&gt;
&lt;!ATTLIST menu.items title CDATA #IMPLIED&gt;
&lt;!ELEMENT menu-div (html-page,popup-items)&gt;
&lt;!ELEMENT popup-items (html-page*)&gt;</pre><img-text-block>The children of html-page element are the top objects. You can install any number of top objects. In the free distribution of WCX Editor we design the html-page object as </img-text-block><pre>&lt;!ELEMENT html-page (head?,img-text-block*,pre*,html-code*)&gt;</pre><img-text-block>The top objects are located by their position. We will call the children of the top objects merely the objects.<br/><br/>The objects defined in the package are</img-text-block><pre>&lt;!ELEMENT a (#PCDATA)&gt;
&lt;!ELEMENT ref (#PCDATA)&gt;
&lt;!ELEMENT img (img?)&gt;
&lt;!ELEMENT ul (li*)&gt;
&lt;!ELEMENT br EMPTY&gt;
&lt;!ELEMENT li (#PCDATA|ref|a)&gt;
&lt;!ATTLIST a href CDATA #REQUIRED&gt;
&lt;!ATTLIST a target (_blank) #IMPLIED&gt;
&lt;!ATTLIST ref file IDREF #REQUIRED&gt;
&lt;!ATTLIST img src CDATA #REQUIRED&gt;
&lt;!ATTLIST img width CDATA #IMPLIED&gt;
&lt;!ATTLIST img height CDATA #IMPLIED&gt;
&lt;!ATTLIST img alt CDATA #IMPLIED&gt;
&lt;!ATTLIST img align (left|center|right) 'center'&gt;</pre><img-text-block>An object can be handled by its parent or be completely independent of its parent. The last is an elementary object. Once the top object creates an elementary object child it delegates to the object a part of its functionality.</img-text-block></html-page><popup-items><html-page menu-item="Parameters" file="wcx_editor/parameters"><head><title>Parameters of WCX Editor</title></head><img-text-block><b>Parameters of WCX Editor</b><br/><br/>The &quot;xe_menu.xsl&quot; XSLT stylesheet defines the main dynamic parameters of WCXE package<ul><li>$page is the value of the file attribute of the current html-page selected by the user. It is set by the program.</li><li>$obj.active is the position of the active top object. It is set by the editor.</li><li>$o.type is a boolean parameter indicating that the elementary object is selected for editing. It is handled by the program.</li><li>$o.path is XPATH expression for unambiguous identification of the object. It is computed by the editor.</li><li>$obj.hide is a boolean parameter saying that the link-controllers should not be printed.</li><li>$menu.expand is an integer parameter indicating which of WCXE menus is active.</li><li>$source is the name of the data file.</li></ul></img-text-block></html-page><html-page menu-item="Abstract classes" file="wcx_editor/abstract_stylesheets"><head><title>Abstract XSLT stylesheets of WCX Editor</title></head><img-text-block><b>Abstract classes of WCXE package</b><br/><br/>Abstract class is XSLT stylesheet that employes  not defined variables (parameters) and templates (virtual variables and templates). The lasts are set in the stylesheet importing the functionality of the abstract class. In this package abstract XSLT stylesheets have axsl extension and can not be executed by the parser.<br/><br/><b>&quot;action&quot; XSLT stylesheet</b> is a parent class for all one button press operations. Virtual function is the template with name &quot;xe:action&quot;. It returns updated WCXE document. The WCXE utilities help to modify the document correctly. The current node is the current html-page selected by the user.<br/><b>&quot;add_top_object&quot; XSLT stylesheet</b> is an abstract class for creation of top objects of html-page element. It uses virtual variable &quot;$xe:new_top_object&quot;. The content of this variable will be added to children of the current html-page element. Example,</img-text-block><pre>&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version=&quot;1.0&quot;&gt;
&lt;xsl:include href=&quot;add_top_object.axsl&quot;/&gt;
&lt;xsl:variable name=&quot;xe:new_top_object&quot;&gt;&lt;img-text-block/&gt;&lt;/xsl:variable&gt;
&lt;/xsl:stylesheet&gt;</pre><img-text-block>The stylesheet creates empty img-text-block element. Then the user can select this object to see the object menu provided that it was properly installed in templates section of the package.<br/><b>&quot;action_object&quot; XSLT stylesheet</b> is a parent class for all one button press modification of the oblects. Virtual function is the template with name &quot;xe:object-action&quot;. The current node is the object itself.<br/><b>&quot;add_object&quot; XSLT stylesheet </b>is an abstract class for creation of objects. It uses virtual variable &quot;$xe:new_object&quot;. The content of this variable will be added to children of the current top object.<br/><b>&quot;form&quot; XSLT stylesheet </b>is a parent class for all html forms. The virtual parameters are &quot;form_enctype&quot; and &quot;form_name&quot;. The virtual functions are templates with name &quot;form-fields&quot; and &quot;new-content&quot;. The current node for both of these templates is html-page element.<br/><b>&quot;form_top_object&quot; XSLT stylesheet </b>is a child of the form class. The virtual parameters are &quot;form_enctype&quot; and &quot;form_name&quot;. The virtual functions are templates with name &quot;form-top-object-fields&quot; and &quot;new-top-object-content&quot;. The current node for both of these templates is the top object itself.<br/><b>&quot;form_object&quot; XSLT stylesheet </b>is a child of the form class. The virtual parameters are &quot;form_enctype&quot; and &quot;form_name&quot;. The virtual functions are templates with name &quot;form-object-fields&quot; and &quot;new-object-content&quot;. The current node for both of these templates is the object itself.</img-text-block></html-page><html-page menu-item="WCX Editor utilities" file="wcx_editor/utilities"><head><title>Utilities of WCX Editor</title></head><img-text-block><b>Utilities of WCX Editor</b><br/><br/>WCXE utilities serve for support of XML document object update, insert and delete operations. It is a collection of functions or XSLT named templates. They update the current node and return new XML document. The following functions are available in xe_utils stylesheet.<br/><b>u:replace-current</b> function replaces the current node with new nodes passed through parameter $new-nodes. If $new-nodes is empty node-set the current node will be deleted.<br/><b>u:append-after-current</b> function appends $new-nodes after the current node.<br/><b>u:add-child-to-current</b> function adds $new-nodes to the children of the current node<br/><b>u:add-child-to-current-top</b> function adds $new-nodes at the beginning of the current node children list.<br/><b>u:current-up</b> function has no parameters. It moves the current node position up. If the current node is the first node of its parent nothing will be done and empty document will be returned. Example, </img-text-block><pre>&lt;xsl:variable name=&quot;new-doc&quot;&gt;
&lt;xsl:for-each select=&quot;document('old-doc.xml')/doc-items/item[5]&quot;&gt;
&lt;xsl:variable name=&quot;update-item&quot;&gt;
&lt;xsl:copy&gt;
&lt;xsl:for-each select=&quot;@*[name(.)!='my_attribute']&quot;&gt;&lt;xsl:copy/&gt;&lt;/xsl:for-each&gt;
&lt;xsl:attribute name=&quot;my_attribute&quot;&gt;&lt;!-- new value code --&gt;&lt;/xsl:attribute&gt;
&lt;xsl:copy-of select=&quot;node()&quot;/&gt;
&lt;/xsl:copy&gt;
&lt;/xsl:variable&gt;
&lt;xsl:call-template name=&quot;u:replace-current&quot;&gt;
&lt;xsl:with-param name=&quot;new-nodes&quot; select=&quot;$update-item&quot;/&gt;
&lt;/xsl:call-template&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
</pre><img-text-block>The above code updates the value of my_attribute and returns new document. Notice that if item[5] doesn't exist the variable $new-doc will be empty node-set.</img-text-block></html-page></popup-items></menu-div></menu.items></pages-div></site-map>